const studentRepo = new (require("../data/repo/studentRepo"))();
const generator = require("generate-password");
const {
  constructResponse,
  errorResponse,
  successResponse,
  HashPasswordUsingBcryptjs,
} = require("../utils/allFunctions");
const { HTTP_STATUS, transporter } = require("../utils/constant");
module.exports = class StudentService {
  async addStudent(data) {
    const _password = generator.generate({
      length: 10,
      numbers: true,
    });
    const hashedPassword=await HashPasswordUsingBcryptjs(_password)
    const newStudent = {
      name: data.name,
      father_name: data.father_name,
      email: data.email,
      phone_No: data.phone_no,
      department: data.department,
      semester: data.semester,
      cnic: data.cnic,
      createdAt: new Date(),
      updatedAt: new Date(),
      password: hashedPassword,
    };
    let mailOptions = {
      from: process.env.EMAIL,
      to: data.email,
      subject: "Password",
      text: `Dear ${data.name},[ password: ${_password} ] is your password of teacher evalution system that is generated by system at  ${new Date()} you can
      login using your email and password`,
    };
    try {
      const isExist = await studentRepo.getStudentByEmail(data.email);
      if (isExist) {
          return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR,"student is already registered");
      }
      else {
          try {
            const dbResponse = await studentRepo.addStudentInToDb(newStudent);
            transporter.sendMail(mailOptions, (error) => {
              if (error) {
                return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
              } else {
                console.log("mail has been sent");
              }
            });
            return successResponse(
              dbResponse.dataValues,
              HTTP_STATUS.CREATED,
              "new student has added successfully"
            );
          } catch (error) {
            return errorResponse(
              HTTP_STATUS.INTERNAL_SERVER_ERROR,
              error.message
            );
          }
      }
    } catch (error) {
      return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
    }
    try {
      const dbResponse = await studentRepo.addStudentInToDb(newStudent);
      transporter.sendMail(mailOptions, (error) => {
        if (error) {
          console.log(error);
          return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error);
        } else {
          console.log("mail has been sent");
        }
      });
      return successResponse(
        dbResponse.dataValues,
        HTTP_STATUS.CREATED,
        "new student has added successfully"
      );
    } catch (error) {
      return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
    }
  }
  async getAllStudent() {
    try {
      const dbResponse = await studentRepo.getAllStudentFromDb();
      return successResponse(dbResponse, HTTP_STATUS.OK, "all data fetched");
    } catch (error) {
      return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
    }
  }
  async deleteStudentInfo(id) {
    try {
      const dbResponse = await studentRepo.deleteStudentFromDb(id);
      return dbResponse
        ? successResponse([], HTTP_STATUS.OK, "data deleted successfully")
        : successResponse([], HTTP_STATUS.NOT_FOUND, "student is not exist");
    } catch (error) {
      return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
    }
  }
  async getStudentInfoById(id) {
    try {
      const dbResponse = await studentRepo.getStudentInfoByIdFromDb(id);
      return dbResponse
        ? successResponse(
            dbResponse.dataValues,
            HTTP_STATUS.OK,
            " data fetched"
          )
        : successResponse([], HTTP_STATUS.NOT_FOUND, "student is not exist");
    } catch (error) {
      return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
    }
  }
  async getStudentRatingInformation(id) {
     try {
       const dbResponse = await studentRepo.getStudentRatingInformationFromDb(id);
       return dbResponse
         ? successResponse(
             dbResponse,
             HTTP_STATUS.OK,
             " data fetched"
           )
         : successResponse([], HTTP_STATUS.NOT_FOUND, "rating is not exist");
     } catch (error) {
       return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
     }
  }
  async addRating(data){
    const { star, feedback, stu_id, teacher_id, type_fb } = data;
    const newRating = {
      no_of_star: star,
      type_of_feedback:type_fb,
      feedback:feedback,
      StudentId:stu_id,
      TeacherId:teacher_id
    };
   try {
     const dbResponse = await studentRepo.addRatingInToDb(newRating);
     return successResponse(
       dbResponse.dataValues,
       HTTP_STATUS.CREATED,
       "new rating has added successfully"
     );
   } catch (error) {
     return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
   }
  }
  async updateStudentInfo(data, id) {
    const newData = {
      name: data.name,
      father_name: data.father_name,
      email: data.email,
      phone_No: data.phone_No,
      department: data.department,
      semester: data.semester,
      password: data.password,
      cnic:data.cnic,
      updatedAt: new Date(),
    };
    try {
      const [dbResponse] = await studentRepo.updateStudentFromDb(newData, id);
      return dbResponse
        ? successResponse([], HTTP_STATUS.OK, "data updated")
        : successResponse([], HTTP_STATUS.NOT_FOUND, "student is not exist");
    } catch (error) {
      return errorResponse(HTTP_STATUS.INTERNAL_SERVER_ERROR, error.message);
    }
  }
};
